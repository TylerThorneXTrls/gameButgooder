<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Movement</title>
    <link rel="stylesheet" href="syles.css">
</head>
<body>
        <div style="position:sticky; left: 0;top:0; width:200px;aspect-ratio:1/1;z-index:2;"id="scorebox"></div>
        <canvas id="myCanvas" style=" width:2000;height: 2000;z-index: 0; position:fixed;left:0px;top:0px"></canvas>
    <script>
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const scorebox = document.getElementById('scorebox');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        const maxFrame = 3
        let frameIndex = 0


        const imageCache = {};
        function loadImage(path) {
            if (!path) return null;
            if (!imageCache[path]) {
                const img = new Image();
                img.src = path;
                imageCache[path] = img;
            }
            return imageCache[path];
        }

        var mousePositionX =0
        var mousePositionY =0
        let newProjectile = true
        enmiems = []
        let score =0
        const playerProjectiles = {
            img:"./energy.gif",
            frames:3,
            frameLength:10,
            frameheight:10,
            frameRate:250,
            colums:0
        }
        const playerMovingLeft = {
            img:"./playerMovingLeft.png",
            frames:3,
            frameLength:50,
            frameheight:100,
            frameRate:100,
        }
        const playerMovingRight = {
            img:"./playerMovingRight.png",
            frames:3,
            frameLength:50,
            frameheight:100,
            frameRate:100,
            colums:0
        }
        const enemySpreadSheet = {
            img:"/accrochemur.png",
            frames:3,
            frameLength:85,
            frameheight:56,
            frameRate:100,
            colums:0
        }
         const enemySpreadSheetLizard = {
            img:"/lizardMan.png",
            img2:"lizardmanLeft.png",
            frames:3,
            frameLength:100,
            frameheight:100,
            frameRate:250,
            colums:0
        }
        
        const playerSwordProjectile ={
            img:"./swordSprite.png",
            frames:3,
            frameLength:10,
            frameheight:50,
            frameRate:100,
            colums:2
        }

        class Entity {
            constructor(x, y, width, height, color, speed = 2,angle=1,enemy=false,spreadsheetinfo=null,health = 10) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.speed = speed;
                this.angle = angle
                this.image = spreadsheetinfo ? loadImage(spreadsheetinfo.img) : null;
                this.frameIndex = 0;
                this.spriteTime = Date.now();
                this.spreadsheetinfo = spreadsheetinfo
                this.direction 
                this.health = health
                this.projectilesHit = []
                this.id= Math.random()
                this.hitTime = null
                this.iframe = false
                this.enemy = enemy
            }

            draw() {
                if(this.spreadsheetinfo){
                this.image = this.spreadsheetinfo ? loadImage(this.spreadsheetinfo.img) : null
                  if(this.direction==="left"&&this.spreadsheetinfo.img2){
                    this.image = this.spreadsheetinfo.img2 ? loadImage(this.spreadsheetinfo.img2) : null

                }
                ctx.drawImage(
                this.image,
                this.frameIndex * this.spreadsheetinfo.frameLength,  // ✅ Source X: frame index * frame width
                0,                                           // ✅ Source Y: top of the spritesheet
                this.spreadsheetinfo.frameLength,              // ✅ Source width (frame width)
                this.spreadsheetinfo.frameheight,              // ✅ Source height (frame height)
                this.x, this.y,                             // ✅ Destination X and Y
                this.width, this.height)   // ✅ Destination width and height\\
                ;
                if( Date.now()- this.hitTime < 100){
                    ctx.globalCompostionOperation = 'source-atop'
                    ctx.fillStyle = "rgba(255, 0, 0, 0.6)";
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    ctx.globalCompostionOperation = 'source-over'

                }  
            }}
            UpdateFrame(){
                const currentTime = Date.now();
                if(this.spreadsheetinfo.frameRate<= currentTime - this.spriteTime){
                    this.frameIndex = (this.frameIndex + 1) % this.spreadsheetinfo.frames;
                    this.spriteTime = currentTime;


            }
            else return}

            move(dx, dy) {
                this.x = Math.max(0, Math.min(this.x + dx, canvas.width - this.width));
                this.y = Math.max(0, Math.min(this.y + dy, canvas.height - this.height));
            }
            findangle(x,y){
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;
                let subx =   x- cx ;
                let suby =  y-cy;
                let angle = Math.atan2(suby, subx);

                this.angle = angle;
                return angle;
            }
            pathFind(){
                let angle = this.findangle(player.x+player.width/2,player.y+player.height/2)
                    
                let sp =this.speed

                const mx = Math.cos(this.angle) * sp;
                const my = Math.sin(this.angle) * sp;
                this.direction = mx>0 ? "right" : "left"

                this.x = Math.max(0, Math.min(this.x + mx, canvas.width - this.width));
                this.y = Math.max(0, Math.min(this.y + my, canvas.height - this.height));
            }
            hit(entity){
                entity.forEach((projectile, index)=>{
                    if (hitBox(this,projectile)&& !this.iframe) {

                            
                    if((!this.projectilesHit.includes(projectile)|!this.enemy)){
                        this.health -= 1
                        console.log(this.health)
                        this.projectilesHit.push(projectile)
                        this.hitTime = Date.now()
                        
                        if(!this.enemy){
                            this.iframe = true



                              setTimeout(() => {
                                 this.iframe = false

                                },500)

                        }

                    }
                if(this.health<=0&& this.enemy){
                enmiems.splice(enmiems.indexOf(this),1)
                score += 1

                            scorebox.innerHTML = `Score: ${score}`

                    }}
                })
            }
        }
        function hitBox(one ,two){
            if (one.x < two.x + two.width &&
                one.x + one.width > two.x &&
                one.y < two.y + two.height &&
                one.y + one.height > two.y){
                            return true
                        } else {
                            return false
                        }
        }
        function Iframs(entity){
          
        }
        
        
        class Projectile {
    constructor(x, y, speed, angle, width = 5,height=5, color = "black",projectileSpriteSheet,lifeTime=5000) {
        this.x = x- width/2;
        this.y = y- height/2;
        this.width = width;
        this.height = height;
        this.color = color;
          this.angle = angle;

        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.image = projectileSpriteSheet ? loadImage(projectileSpriteSheet.img) : null;
        this.spriteTime = Date.now();
        this.lifeTime = lifeTime
        this.startTime = Date.now()
        this.spreadsheetinfo = projectileSpriteSheet
        this.frameIndex = 0;
        this.currentColums = 0
        this.id=Math.random()
    }

    move() {
        if (Date.now() - this.startTime > this.lifeTime) {
            playerProjectile.splice(playerProjectile.indexOf(this),1)}
        this.x += this.vx;
        this.y += this.vy;
    }
draw() { 

                if(this.spreadsheetinfo){
                this.image = this.spreadsheetinfo.img ? loadImage(this.spreadsheetinfo.img) : null

              

             
               
                ctx.drawImage(
                this.image,
                this.frameIndex * this.spreadsheetinfo.frameLength,  // ✅ Source X: frame index * frame width
                this.currentColums*this.spreadsheetinfo.frameheight,   // ✅ Source Y: top of the spritesheet
                this.spreadsheetinfo.frameLength,              // ✅ Source width (frame width)
                this.spreadsheetinfo.frameheight,              // ✅ Source height (frame height)
                this.x, this.y,                             // ✅ Destination X and Y
                this.width, this.height)   // ✅ Destination width and height\\                 // ✅ Destination width and height
;
                    
                }
            }
    UpdateFrame(){
        const currentTime = Date.now()
        const timeElapsed = currentTime - this.spriteTime

        if (this.spreadsheetinfo && timeElapsed >= this.spreadsheetinfo.frameRate) {
            this.frameIndex += 1
            this.spriteTime = currentTime

            if (this.frameIndex >= this.spreadsheetinfo.frames) {
                this.frameIndex = 0

            }
        }
        




    }
    
    
    
}


        const player = new Entity(0, 0, 45, 90, "none",4,2,false,playerMovingLeft)
        const camera = {
     x: 0,
     y: 0,
     width: window.innerWidth,
     height: window.innerHeight
};
        const playerProjectile = []

        const keyMovement = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false
        };

        window.addEventListener('keydown', (e) => {
            if (keyMovement.hasOwnProperty(e.key)) {
                keyMovement[e.key] = true;
            }
            
        });

        window.addEventListener('keyup', (e) => {
            if (keyMovement.hasOwnProperty(e.key)) {
                keyMovement[e.key] = false;
                player.image = loadImage("/standing.gif")
            }
        });
        addEventListener('keydown',(e)=>{
            if(e.key==="f"){
                let angle = player.findangle(mousePositionX, mousePositionY)
                const swordWidth = 20;
                const swordHeight = 200;
                const newSword = new Projectile(player.x + player.width / 2 ,player.y + player.height / 2 ,10, angle, swordWidth, swordHeight, "black", playerSwordProjectile, 100);

                playerProjectile.push(newSword)}
            
        })

        function runloop() {
            console.log(player.iframe)

            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        player.UpdateFrame()


            if (keyMovement.ArrowUp) {
                player.move(0, -player.speed)
            };
            if (keyMovement.ArrowDown) player.move(0, player.speed);
            if (keyMovement.ArrowLeft) {player.move(-player.speed, 0)
                player.spreadsheetinfo = playerMovingLeft
            };
            if (keyMovement.ArrowRight) {player.move(player.speed, 0)
                player.spreadsheetinfo = playerMovingRight}

            player.hit(enmiems)
            player.draw();
            playerProjectile.forEach((projectiel)=>{
                projectiel.move()
                projectiel.UpdateFrame()
                projectiel.draw()
            })

            enmiems.forEach((ememey)=>{
                ememey.pathFind()
                ememey.UpdateFrame()
                ememey.hit(playerProjectile)
                ememey.draw()
            })
            requestAnimationFrame(runloop);
        }

        addEventListener('mousemove', (m) => {
            fixed = canvas.getBoundingClientRect()
            mousePositionX = m.clientX 
            mousePositionY = m.clientY 
        })

       
        addEventListener('click', () => {
            if (newProjectile) {
                let angle = player.findangle(mousePositionX, mousePositionY)
                const projectile = new Projectile((player.x + player.width / 2), (player.y + player.height / 2), 3, angle,30,30,"black",playerProjectiles )
                playerProjectile.push(projectile)
                newProjectile = false
                setTimeout(() => { newProjectile = true }, 300)
            }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
        })
        setInterval(()=>{
            let randomX = Math.round(((Math.random() * canvas.width)))
            let randomY =  (canvas.width/2) * (1 - (-1) ** randomX)
            console.log(randomY)
                        let angle = player.findangle(randomX, randomY);

                    let ememey = new Entity(randomX,randomY,80,80,"blue",2,0,true,enemySpreadSheet,1)
                    enmiems.push(ememey)
        },1000)
         setInterval(()=>{
            let randomX =Math.round((Math.random() * canvas.width))
            let randomY =  (canvas.width+30/2) * (1 - (-1) ** randomX)
            console.log(randomY)
            let angle = player.findangle(randomX, randomY);

            let ememey = new Entity(randomX,randomY,200,200,"blue",2,0,true,enemySpreadSheetLizard,10)
            enmiems.push(ememey)
        },5000)

        

        runloop();

    </script>
</body>
</html>
